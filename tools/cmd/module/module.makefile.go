package module

import (
	"fmt"
	"strings"
)

var template string = `

### THIS FILE IS GENERATED BY THE GEN-MODULE TOOL ###

CPP=%s
CFLAGS=%s
ODIR=../../../build/obj
LDIR=../../../build/lib


.PHONY: build

MODULE_NAME=%s
LIB_NAME=%s

DRIVER:=../../driver/$(MODULE_NAME)/src/%%.cpp
ADAPTER:=../../adapter/$(MODULE_NAME)/src/%%.cpp
USECASE:=../../usecase/$(MODULE_NAME)/src/%%.cpp
DOMAIN:=../../domain/$(MODULE_NAME)/src/%%.cpp


HEADER_FILES:=$(wildcard ../../*/$(MODULE_NAME)/include/*.h*) $(wildcard ../../*/$(MODULE_NAME)/include/gen/*.h*)

# SOURCE FILES
SOURCE_FILES:=$(wildcard ../../*/$(MODULE_NAME)/src/*.c*) $(wildcard ../../*/$(MODULE_NAME)/src/gen/*.c*)
DRIVER_SOURCE_FILES:=$(wildcard ../../driver/$(MODULE_NAME)/src/*.c*) $(wildcard ../../driver/$(MODULE_NAME)/src/gen/*.c*)
DOMAIN_SOURCE_FILES:=$(wildcard ../../domain/$(MODULE_NAME)/src/*.c*) $(wildcard ../../domain/$(MODULE_NAME)/src/gen/*.c*)
ADAPTER_SOURCE_FILES:=$(wildcard ../../adapter/$(MODULE_NAME)/src/*.c*) $(wildcard ../../adapter/$(MODULE_NAME)/src/gen/*.c*)
USECASE_SOURCE_FILES:=$(wildcard ../../usecase/$(MODULE_NAME)/src/*.c*) $(wildcard ../../usecase/$(MODULE_NAME)/src/gen/*.c*)

# OBJECT FILES
DRIVER_OBJECT_FILES:=$(patsubst %%.cpp, $(ODIR)/$(MODULE_NAME)/%%.o, $(notdir $(DRIVER_SOURCE_FILES)))
DOMAIN_OBJECT_FILES:=$(patsubst %%.cpp, $(ODIR)/$(MODULE_NAME)/%%.o, $(notdir $(DOMAIN_SOURCE_FILES)))
ADAPTER_OBJECT_FILES:=$(patsubst %%.cpp, $(ODIR)/$(MODULE_NAME)/%%.o, $(notdir $(ADAPTER_SOURCE_FILES)))
USECASE_OBJECT_FILES:=$(patsubst %%.cpp, $(ODIR)/$(MODULE_NAME)/%%.o, $(notdir $(USECASE_SOURCE_FILES)))

OBJECT_FILES:=$(DRIVER_OBJECT_FILES) $(DOMAIN_OBJECT_FILES) $(ADAPTEER_OBJECT_FILES) $(USECASE_OBJECT_FILES)

#DEPENDENCIES 
DRIVER_DEPENDENCIES:=%s
DOMAIN_DEPENDENCIES:=%s
ADAPTER_DEPENDENCIES:=%s
USECASE_DEPENDENCIES:=%s

DEPENDENCIES:=$(DRIVER_DEPENDENCIES) $(DOMAIN_DEPENDENCIES) $(ADAPTER_DEPENDENCIES) $(USECASE_DEPENDENCIES)

$(DRIVER_OBJECT_FILES): $(ODIR)/$(MODULE_NAME)/%%.o : $(DRIVER) $(DRIVER_DEPENDENCIES)
	$(CPP) -c $< -o $@ $(CFLAGS)

$(DOMAIN_OBJECT_FILES): $(ODIR)/$(MODULE_NAME)/%%.o : $(DOMAIN) $(DOMAIN_DEPENDENCIES)
	$(CPP) -c $< -o $@ $(CFLAGS)

$(ADAPTER_OBJECT_FILES): $(ODIR)/$(MODULE_NAME)/%%.o : $(ADAPTER) $(ADAPTER_DEPENDENCIES)
	$(CPP) -c $< -o $@ $(CFLAGS)

$(USECASE_OBJECT_FILES): $(ODIR)/$(MODULE_NAME)/%%.o : $(USECASE) $(USECASE_DEPENDENCIES)
	$(CPP) -c $< -o $@ $(CFLAGS)

build-library: $(OBJECT_FILES)
	ar -crs $(LDIR)/$(MODULE_NAME)/$(LIB_NAME).a $(OBJECT_FILES)
	$(CPP) -shared -fPIC -o $(shell pwd)/$(LDIR)/$(MODULE_NAME)/$(LIB_NAME).so $(SOURCE_FILES) $(DEPENDENCIES) $(CFLAGS)

build: build-library

install:
	sudo cp $(LDIR)/$(MODULE_NAME)/$(LIB_NAME).so %s

%s`

func getMakeRules(makeRules []MakeRule) string {
	makeRulesString := ""

	for _, makeRule := range makeRules {
		makeRulesString += makeRule.Name + ": "

		if len(makeRule.Dependencies) > 0 || len(makeRules) > 0 {
			makeRulesString += makeRule.Dependencies + "\n"
		}

		commands := strings.Join(makeRule.Commands, "\n")
		commands = strings.ReplaceAll(commands, "\\", "\\\n")

		commandsArray := strings.Split(commands, "\n")

		for i, command := range commandsArray {
			commandsArray[i] = strings.TrimSpace(command)
		}
		commands = "\t" + strings.Join(commandsArray, "\n\t")

		makeRulesString += commands + "\n"

		if len(makeRule.Commands) > 0 {
			makeRulesString += "\n"
		}
	}
	return makeRulesString + "\n"
}

func MakeMakefile(module Module) string {

	extraMakeRules := getMakeRules(module.MakeRules)
	return fmt.Sprintf(template,
		module.Compiler,
		module.Flags,
		module.Name,
		module.LibraryName,
		strings.Join(module.Dependencies.Driver[:], " "),
		strings.Join(module.Dependencies.Domain[:], " "),
		strings.Join(module.Dependencies.Adapter[:], " "),
		strings.Join(module.Dependencies.Usecase[:], " "),
		module.InstallationFolder,
		extraMakeRules,
	)
}
